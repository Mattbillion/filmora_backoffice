import { QueryParams } from '@/lib/utils';

import * as actions from '../api/actions';
import { executeRevalidate } from '../api/helpers';
import { ID, PaginatedResType } from '../api/types';
import { {{pascalCase route-name}}BodyType, {{pascalCase route-name}}ItemType, RVK_{{constantCase route-name}} } from './schema';

{{#if rawData}}
  {{#each endpointList}}
    {{#if (isGetRequest method name)}}
      {{> svcGetRequest name=name method=method pathList=pathList route-name=../route-name}}
    {{/if}}
    {{#if (isGetDetailRequest method name)}}
      {{> svcGetDetailRequest name=name method=method pathList=pathList route-name=../route-name}}
    {{/if}}
    {{#if (isDeleteRequest method)}}
      {{> svcDeleteRequest name=name method=method pathList=pathList route-name=../route-name}}
    {{/if}}
    {{#if (isPostRequest method)}}
      {{> svcCreateRequest name=name method=method pathList=pathList route-name=../route-name}}
    {{/if}}
    {{#if (isPutRequest method)}}
      {{> svcUpdateRequest name=name method=method pathList=pathList route-name=../route-name}}
    {{/if}}
  {{/each}}
{{else}}
// Fallback minimal implementations (no rawData)
export const create{{pascalCase route-name}} = async (bodyData: {{pascalCase route-name}}BodyType) => {
  const res = await actions.post(`/{{snakeCase endpoint}}`, bodyData);
  const { body, error } = res;
  if (error) throw new Error(error);
  executeRevalidate([RVK_{{constantCase route-name}}]);
  return { data: body, error: null };
};

export const patch{{pascalCase route-name}}Detail = async ({ id: param1, ...bodyData }: {{pascalCase route-name}}BodyType & { id: ID }) => {
  const res = await actions.put(`/{{snakeCase endpoint}}/${param1}`, bodyData) as { body: { data: {{pascalCase route-name}}ItemType }; error?: string };
  const { body, error } = res;
  if (error) throw new Error(error);
  executeRevalidate([RVK_{{constantCase route-name}}, RVK_{{constantCase route-name}} + '_' + String(param1)]);
  return { data: body, error: null };
};

export const delete{{pascalCase route-name}}Detail = async (param1: string | ID) => {
  const res = await actions.destroy(`/{{snakeCase endpoint}}/${param1}`);
  const { body, error } = res;
  if (error) throw new Error(error);
  executeRevalidate([RVK_{{constantCase route-name}}, RVK_{{constantCase route-name}} + '_' + String(param1)]);
  return { data: body, error: null };
};

export const get{{pascalCase route-name}} = async (searchParams?: QueryParams) => {
  try {
    const res = await actions.get<
PaginatedResType< {{pascalCase route-name}}ItemType[] >
>('/{{snakeCase endpoint}}', {
      searchParams,
      next: { tags: [RVK_{{constantCase route-name}}] },
    });
    const { body, error } = res;
    if (error) throw new Error(error);
    return { data: body, total_count: body.total_count };
  } catch (error) {
    console.error('Error fetching {{kebabCase endpoint}}:', error);
    return { data: { data: [], total_count: 0 }, error };
  }
};

export const get{{pascalCase route-name}}Detail = async (id: string) => {
  try {
    const res = await actions.get<{ data: {{pascalCase route-name}}ItemType }>(`/{{snakeCase endpoint}}/${id}`, {
      next: { tags: [RVK_{{constantCase route-name}} + '_' + String(id)] },
    });
    const { body, error } = res;
    if (error) throw new Error(error);
    return { data: body };
  } catch (error) {
    console.error('Error fetching {{kebabCase endpoint}}:', error);
    return { data: null, error };
  }
};
{{/if}}
